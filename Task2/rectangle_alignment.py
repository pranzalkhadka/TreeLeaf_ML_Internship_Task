# -*- coding: utf-8 -*-
"""Rectangle_Alignment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gmnF4j5qNLr6IqYDPcOpoTV0als4Mkte
"""

import cv2
import numpy as np

# Reading the image
image = cv2.imread('/content/drive/MyDrive/task_image.png')

# Converting the image to grayscale
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Applying GaussianBlur to reduce noise
gray_blurred = cv2.GaussianBlur(gray, (5, 5), 0)

# Using Canny edge detection to find edges
edges = cv2.Canny(gray_blurred, 50, 150)

# Converting the edges image back to color for contour detection
edges_color = cv2.cvtColor(edges, cv2.COLOR_GRAY2BGR)

# Finding contours in the edges image
contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

line_lengths = {}
# Created a dictionary to store line lengths for each rectangle

# Looping through the contours and drawing rectangles around them
for idx, contour in enumerate(contours):
    perimeter = cv2.arcLength(contour, True)
    approx = cv2.approxPolyDP(contour, 0.02 * perimeter, True)

    if len(approx) == 4:
        x, y, w, h = cv2.boundingRect(approx)
        # Getting the bounding box of rectangle

        cv2.drawContours(image, [approx], 0, (0, 255, 0), 2)

        # Reordering the corner points of the rectangle in a consistent order
        corners = np.array([point[0] for point in approx])
        sorted_corners = np.zeros((4, 2), dtype=np.float32)
        # The top left corner has the smallest sum of x and y
        # The bottom right corner has the largest sum of x and y
        sorted_corners[0] = corners[np.argmin(np.sum(corners, axis=1))]
        sorted_corners[2] = corners[np.argmax(np.sum(corners, axis=1))]
        # The top right corner has the smallest difference of x and y
        # The bottom left corner has the largest difference of x and y
        sorted_corners[1] = corners[np.argmin(np.diff(corners, axis=1))]
        sorted_corners[3] = corners[np.argmax(np.diff(corners, axis=1))]

        # Defining the target rectangle with desired dimensions for alignment
        target_rect = np.array([[0, 0], [w - 1, 0], [w - 1, h - 1], [0, h - 1]], dtype=np.float32)

        # Performing transformation to align the rectangle
        transformation_matrix = cv2.getPerspectiveTransform(sorted_corners, target_rect)
        aligned_rectangle = cv2.warpPerspective(image, transformation_matrix, (w, h))

        # Replacing the original rectangle with the aligned one
        image[y:y+h, x:x+w] = aligned_rectangle


from google.colab.patches import cv2_imshow
cv2_imshow(image)
cv2.waitKey(0)
cv2.destroyAllWindows()

