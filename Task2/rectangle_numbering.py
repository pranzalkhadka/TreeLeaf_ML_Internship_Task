# -*- coding: utf-8 -*-
"""Rectangle_Numbering.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jwa_vY8s4qocJXwHZGn5OdQUWej9N9Ob
"""

import cv2
import numpy as np

# Reading the image
image = cv2.imread('/content/drive/MyDrive/task_image.png')

# Converting the image to grayscale
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Applying GaussianBlur to the image to reduce noise
gray_blurred = cv2.GaussianBlur(gray, (5, 5), 0)

# finding edges in the image using Canny edge detection
edges = cv2.Canny(gray_blurred, 50, 150)

# Converting the edges from grayscale to color for contour detection
edges_color = cv2.cvtColor(edges, cv2.COLOR_GRAY2BGR)

# Finding contours in the image
contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

line_lengths = {}
# Created a dictionary to store line lengths for each rectangle

# Looping through the contours and drawing rectangles around them
for idx, contour in enumerate(contours):
    perimeter = cv2.arcLength(contour, True)
    approx = cv2.approxPolyDP(contour, 0.02 * perimeter, True)
    if len(approx) == 4:
        cv2.drawContours(image, [approx], 0, (0, 255, 0), 2)

        x, y, w, h = cv2.boundingRect(approx)
        # Getting the bounding box of rectangle

        mask = np.zeros_like(edges)
        cv2.drawContours(mask, [approx], 0, 255, thickness=cv2.FILLED)
        masked_edges = cv2.bitwise_and(edges, mask)
        # A mask is created to isolate the region containing the rectangle by filling the interior of the rectangle

        # Using Hough Line Transform to detect lines in the masked region
        lines = cv2.HoughLinesP(masked_edges, rho=1, theta=np.pi/180, threshold=60, minLineLength=20, maxLineGap=5)

        # Drawing the lines on the original image and calculating the line lengths
        if lines is not None:
            for line in lines:
                x1, y1, x2, y2 = line[0]
                # Checking if both endpoints of the line are inside the rectangle and not too close to the border
                buffer_zone = 10
                if x + buffer_zone < x1 < x + w - buffer_zone and y + buffer_zone < y1 < y + h - buffer_zone \
                        and x + buffer_zone < x2 < x + w - buffer_zone and y + buffer_zone < y2 < y + h - buffer_zone:
                    cv2.line(image, (x1, y1), (x2, y2), (255, 0, 0), 2)
                    # Calculating the length of the line
                    length = np.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
                    # Storing the length in the dictionary
                    line_lengths[idx] = length

sorted_rectangles = sorted(line_lengths.items(), key=lambda x: x[1])
# Sorted the rectangles based on line lengths

# Assigning numbers 1 to 4 based on the sorted order
for i, (idx, _) in enumerate(sorted_rectangles):
    x, y, _, _ = cv2.boundingRect(contours[idx])
    text = str(i + 1)
    font = cv2.FONT_HERSHEY_SIMPLEX
    font_scale = 1
    font_thickness = 2
    text_size = cv2.getTextSize(text, font, font_scale, font_thickness)[0]
    text_x = int(x + (w - text_size[0]) / 2)
    text_y = int(y + h + text_size[1])
    cv2.putText(image, text, (text_x, text_y), font, font_scale, (0, 0, 0), font_thickness, cv2.LINE_AA)


from google.colab.patches import cv2_imshow
cv2_imshow(image)
cv2.waitKey(0)
cv2.destroyAllWindows()

